pragma circom 2.1.2;

template IsZero() {
    signal input in;
    signal output out;

    signal inv;

    inv <-- in!=0 ? 1/in : 0;

    out <== -in*inv +1;
    in*out === 0;
}

template IsEqual() {
    signal input in[2];
    signal output out;

    component isz = IsZero();

    in[1] - in[0] ==> isz.in;

    isz.out ==> out;
}

template TupleCheck (k) {
    signal input address;
    signal input sig;
    signal output result;

    var tuple[k][2] = [
        [1446911596554066059610921290265946649894917611949, 31408101598005189655735533621195091492509677063569],
        [129394504787394156839024801174952106571260817630, 15318967113085362415445465826082254278308254046836],
        [528701938266836256628719186334861515013823086979, 39876192374628134651823478129486124675124981256692],
        [745253789490031892373048491809728539138370331466, 34293761235048126547192470125612401256891256127651],
        [1110097529803548269064008033120412046377309536514, 12874927814391284612486132498325781246182763128376],
        [859209838077040173228859183771985777791319063041, 98723657813410789264129746182645789236476234391844],
        [1434030107996907377889842306413370399778155858092, 76319823864714986134617254872346712498273548713624],
        [209751645627036141276962602553040052648188173585, 318756175398235712349872371245867358932497623140978],
        [84308873002770176700070931361272467791268106173, 378156234978126438612498712476152349843292345762313],
        [1077835431280729172980970930939560708805629391009, 352973612479081498731827239192391238912784654124235],
        [843243948368926777807602105913418290037952605838, 235761238461987412487651248724598123641827654124987],
        [1159880667363450018669653905915900999877912757379, 245972348671249823467910997457634598023928762358723]
    ];

    component compare[k];
    signal address_equal[k];
    component compare2[k];
    signal sig_equal[k];
    signal num_equal[k];
    for (var i=0; i < k; i++) {
        compare[i] = IsEqual();
        compare[i].in[0] <== address;
        compare[i].in[1] <== tuple[i][0];
        address_equal[i] <== compare[i].out;

        compare2[i] = IsEqual();
        compare2[i].in[0] <== sig;
        compare2[i].in[1] <== tuple[i][1];
        sig_equal[i] <== compare2[i].out;

        num_equal[i] <== address_equal[i] * sig_equal[i];
    }

    var resultVar = 0;
    for (var i=0; i < k; i++) {
        resultVar += num_equal[i];
    }
    result <== resultVar;
}

component main { public [ address ] } = TupleCheck(12);